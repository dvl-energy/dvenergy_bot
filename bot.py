
import os
import logging
from fastapi import FastAPI, Request
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    ContextTypes,
    filters,
)
from datetime import datetime

TOKEN = os.getenv("TOKEN")
WEBHOOK_DOMAIN = os.getenv("WEBHOOK_DOMAIN", "https://your-app-name.onrender.com")
PORT = int(os.environ.get("PORT", 10000))

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()
bot_app = (
    ApplicationBuilder()
    .token(TOKEN)
    .build()
)

TRAINING_A = [
    "–ü–æ–¥—Ç—è–≥–∏–≤–∞–Ω–∏—è / —Ç—è–≥–∞ –±–ª–æ–∫–∞ ‚Äî 3x8‚Äì10",
    "–ë–æ–ª–≥–∞—Ä—Å–∫–∏–µ –ø—Ä–∏—Å–µ–¥—ã ‚Äî 3x8",
    "–ñ–∏–º –≥–∞–Ω—Ç–µ–ª–µ–π –ª—ë–∂–∞ ‚Äî 3x10",
    "–ì–∏–ø–µ—Ä—ç–∫—Å—Ç–µ–Ω–∑–∏—è ‚Äî 3x15",
    "–¢—è–≥–∞ –≥–∞–Ω—Ç–µ–ª–∏ –≤ –Ω–∞–∫–ª–æ–Ω–µ ‚Äî 3x10",
]

TRAINING_B = [
    "–ñ–∏–º –≥–∞–Ω—Ç–µ–ª–µ–π —Å—Ç–æ—è ‚Äî 3x8",
    "–ì–æ–±–ª–µ—Ç-–ø—Ä–∏—Å–µ–¥ ‚Äî 3x10",
    "–Ø–≥–æ–¥–∏—á–Ω—ã–π –º–æ—Å—Ç–∏–∫ ‚Äî 3x15",
    "–ü–æ–¥—ä—ë–º –Ω–æ–≥ –≤ –≤–∏—Å–µ ‚Äî 3x15",
    "–ò–Ω—Ç–µ—Ä–≤–∞–ª—å–Ω—ã–π –≤–µ–ª–æ 30/30 ‚Äî 10 –º–∏–Ω",
]

STRETCH_LIST = [
    "–®–µ—è –∏ –ø–ª–µ—á–∏ ‚Äî 2 –º–∏–Ω",
    "–ì—Ä—É–¥–Ω–æ–π –æ—Ç–¥–µ–ª ‚Äî 2 –º–∏–Ω",
    "–ü–æ—è—Å–Ω–∏—Ü–∞ –ª—ë–∂–∞ ‚Äî 2 –º–∏–Ω",
    "–ë—ë–¥—Ä–∞ –∏ —Ç–∞–∑ ‚Äî 2 –º–∏–Ω",
    "–ò–∫—Ä—ã –∏ —Å—Ç–æ–ø—ã ‚Äî 2 –º–∏–Ω",
]

OFFDAY_LIST = [
    "–ü—Ä–æ–≥—É–ª–∫–∞ –Ω–∞ —Å–≤–µ–∂–µ–º –≤–æ–∑–¥—É—Ö–µ ‚Äî 30 –º–∏–Ω",
    "–î—ã—Ö–∞–Ω–∏–µ 4-7-8 ‚Äî 5 –º–∏–Ω",
    "–ö–æ–Ω—Ç—Ä–∞—Å—Ç–Ω—ã–π –¥—É—à –∏–ª–∏ –±–∞–Ω—è",
    "–û—Ç–∫–∞–∑ –æ—Ç –≥–∞–¥–∂–µ—Ç–æ–≤ 1 —á–∞—Å –¥–æ —Å–Ω–∞",
    "–ü–ª–∞–Ω—ã –∏ —Ü–µ–ª–∏ –Ω–∞ –∑–∞–≤—Ç—Ä–∞ ‚Äî 3 –º–∏–Ω",
]

user_logs = {}

def get_training_keyboard(training_list, completed):
    keyboard = []
    for i, item in enumerate(training_list):
        label = f"‚úÖ {item}" if i in completed else f"‚¨ú {item}"
        keyboard.append([InlineKeyboardButton(label, callback_data=f"training_{i}")])
    return InlineKeyboardMarkup(keyboard)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.info("‚ö° /start –≤—ã–∑–≤–∞–Ω")
    await update.message.reply_text("–ü—Ä–∏–≤–µ—Ç! –Ø —Ç–≤–æ–π –±–æ—Ç. –í–≤–µ–¥–∏ /training, /training_a –∏–ª–∏ /training_b")

async def training(update: Update, context: ContextTypes.DEFAULT_TYPE):
    day = datetime.now().weekday()
    if day == 0:
        await training_a(update, context)
    elif day == 3:
        await training_b(update, context)
    else:
        await update.message.reply_text("üìÖ –°–µ–≥–æ–¥–Ω—è –Ω–µ —Å–∏–ª–æ–≤–æ–π –¥–µ–Ω—å. –û—Ç–¥—ã—Ö–∞–π –∏–ª–∏ –Ω–∞–∂–º–∏ /offday")

async def training_a(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["training_type"] = "A"
    context.user_data["completed"] = set()
    keyboard = get_training_keyboard(TRAINING_A, set())
    await update.message.reply_text("üèãÔ∏è‚Äç‚ôÇÔ∏è –¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞ A. –û—Ç–º–µ—á–∞–π –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ:", reply_markup=keyboard)

async def training_b(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["training_type"] = "B"
    context.user_data["completed"] = set()
    keyboard = get_training_keyboard(TRAINING_B, set())
    await update.message.reply_text("üèãÔ∏è‚Äç‚ôÇÔ∏è –¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞ B. –û—Ç–º–µ—á–∞–π –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ:", reply_markup=keyboard)

async def handle_training_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    index = int(query.data.split("_")[1])
    training_type = context.user_data.get("training_type")
    completed = context.user_data.get("completed", set())

    if index in completed:
        completed.remove(index)
    else:
        completed.add(index)

    context.user_data["completed"] = completed
    training_list = TRAINING_A if training_type == "A" else TRAINING_B
    keyboard = get_training_keyboard(training_list, completed)

    if len(completed) == len(training_list):
        await query.edit_message_text("‚úÖ –¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –ö—Ä–∞—Å–∞–≤—á–∏–∫ üí™")
    else:
        await query.edit_message_reply_markup(reply_markup=keyboard)

async def stretch(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [[InlineKeyboardButton(f"‚¨ú {item}", callback_data=f"stretch_{i}")] for i, item in enumerate(STRETCH_LIST)]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("üßò –í–µ—á–µ—Ä–Ω—è—è —Ä–∞—Å—Ç—è–∂–∫–∞:", reply_markup=reply_markup)

async def offday(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [[InlineKeyboardButton(f"‚¨ú {item}", callback_data=f"offday_{i}")] for i, item in enumerate(OFFDAY_LIST)]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("üåø –ü–æ–ª–Ω—ã–π OFF-–¥–µ–Ω—å. –û—Ç–º–µ—á–∞–π –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω–æ–µ:", reply_markup=reply_markup)

async def handle_checklist_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data
    if data.startswith("stretch"):
        items = STRETCH_LIST
        prefix = "stretch"
    elif data.startswith("offday"):
        items = OFFDAY_LIST
        prefix = "offday"
    else:
        return

    index = int(data.split("_")[1])
    session_key = f"{prefix}_done"
    done = context.user_data.get(session_key, set())

    if index in done:
        done.remove(index)
    else:
        done.add(index)

    context.user_data[session_key] = done
    keyboard = [[InlineKeyboardButton(f"‚úÖ {item}" if i in done else f"‚¨ú {item}", callback_data=f"{prefix}_{i}")] for i, item in enumerate(items)]
    await query.edit_message_reply_markup(reply_markup=InlineKeyboardMarkup(keyboard))

async def log_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("‚úçÔ∏è –ù–∞–ø–∏—à–∏ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ –∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç (–ø—Ä–∏–º–µ—Ä: –ñ–∏–º –≥–∞–Ω—Ç–µ–ª–µ–π 24x10)")
    context.user_data["logging"] = True

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if context.user_data.get("logging"):
        user_id = update.effective_user.id
        msg = update.message.text
        user_logs.setdefault(user_id, []).append(msg)
        await update.message.reply_text(f"‚úÖ –ó–∞–ø–∏—Å–∞–Ω–æ: {msg}")
        context.user_data["logging"] = False

@app.on_event("startup")
async def startup():
    logger.info("üöÄ –ó–∞–ø—É—Å–∫ Telegram Webhook")
    bot_app.add_handler(CommandHandler("start", start))
    bot_app.add_handler(CommandHandler("training", training))
    bot_app.add_handler(CommandHandler("training_a", training_a))
    bot_app.add_handler(CommandHandler("training_b", training_b))
    bot_app.add_handler(CallbackQueryHandler(handle_training_callback, pattern="^training_"))
    bot_app.add_handler(CommandHandler("stretch", stretch))
    bot_app.add_handler(CommandHandler("offday", offday))
    bot_app.add_handler(CommandHandler("log", log_command))
    bot_app.add_handler(CallbackQueryHandler(handle_checklist_callback, pattern="^(stretch|offday)_"))
    bot_app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    await bot_app.initialize()
    await bot_app.start()
    await bot_app.bot.set_webhook(f"{WEBHOOK_DOMAIN}/webhook")

@app.post("/webhook")
async def process_webhook(request: Request):
    data = await request.json()
    update = Update.de_json(data, bot_app.bot)
    await bot_app.process_update(update)
    return {"ok": True}
